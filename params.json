{"name":"Image hider","tagline":"An application in Rust that encodes files into PNG images","body":"# Image Hider\r\nAn application in Rust that encodes files into PNG images\r\n\r\nThis project uses the Rust [image crate](https://github.com/PistonDevelopers/image) to encode arbitrary data into image files.\r\n\r\n## Why?\r\nThis provides an easy way to share files. Now you can use image hosts or imageboards.\r\n\r\nAlso, shits and giggles and a proof-of-concept.\r\n\r\n## Usage\r\nTo encode a file:\r\n\r\n    $ image_hider --enc filename\r\n    $ eog filename.png\r\n\r\nTo decode a file:\r\n\r\n    $ image_hider --dec filename.png\r\n    $ xdg-open filename\r\n\r\nTo specify a non-default file name:\r\n\r\n    $ image_hider --enc filename -o output.png\r\n    $ eog output.png\r\n\r\n## Example Output\r\nHere's Alice in Wonderland encoded as an image.\r\n\r\n![Alice in Wonderland](https://i.imgur.com/Ppk4O3O.png)\r\n\r\nNote that the images must be stored in a lossless format. Make sure to check your image host's policy on compression.\r\n\r\n## How it works\r\nRust's image crate is capable of taking an arbitrary vector of bytes and interpretting it as pixel data. In this case, RGBA data was chosen so as to minimize the image dimensions, since each pixel contains four bytes of data.\r\n\r\nTo avoid the issue of deciding on appropriate image dimensions, I decided to make all images square. Thus the dimensions are determined through the equation\r\n\r\n![\\left \\lceil \\sqrt{\\frac{size}{4} + 1} \\right \\rceil](http://latex.codecogs.com/svg.latex?%5Cinline%20%5Ctiny%20%5Cleft%20%5Clceil%20%5Csqrt%7B%5Cfrac%7Bsize%7D%7B4%7D%20&plus;%201%7D%20%5Cright%20%5Crceil)\r\n\r\nThis leads to a problem, however; in order to ensure that the file is square, padding must be added to the end. In order to know exactly where the padding begins, the first pixel is set aside to contain the original file size. Essentially, the file's size is stored as a 32 bit unsigned integer, and through bitwise operations, it is decomposed into four bytes. These bytes are prepended to the vector containing the provided file's data, and then the necessary padding is done.\r\n\r\nThis vector is then fed into a PNGEncoder, which interprets the bytes as RGBA data.\r\n\r\nTo decode a file, the process is essentially reversed.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}